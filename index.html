<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Harmonium ‚Äî play with your laptop keyboard</title>
<meta name="description" content="A free, single-file, browser-based harmonium you can host anywhere (e.g., static.app). Uses only Web Audio API." />
<style>
  :root { --panel:#0f172a; --card:#111827; --ink:#e5e7eb; --muted:#9ca3af; --accent:#22d3ee; --accent2:#a78bfa; }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,Arial;background:linear-gradient(180deg,#05060a,#0a0f1a);color:var(--ink)}
  header{padding:18px 20px;border-bottom:1px solid #1f2937;background:rgba(10,15,26,.6);backdrop-filter:saturate(120%) blur(6px);position:sticky;top:0;z-index:9}
  header h1{margin:0;font-size:20px;letter-spacing:.3px}
  main{max-width:1000px;margin:26px auto;padding:0 16px}
  .row{display:flex;gap:16px;flex-wrap:wrap}
  .card{background:var(--card);border:1px solid #1f2937;border-radius:14px;padding:16px}
  .controls{flex: 1 1 320px}

  /* one-row keyboard container */
  .keyboard{
    position:relative;
    display:inline-block;
    overflow-x:auto;
    white-space:nowrap;
    background:#0b1220;
    border-radius:12px;
    padding:12px;
    flex: 2 1 520px;
  }

  /* keys */
  .key{position:relative;user-select:none;touch-action:none}
  .white{
    display:inline-block;
    position:relative;
    width:50px;
    height:180px;
    background:#fafafa;color:#111;
    border:1px solid #cbd5e1;border-bottom-width:4px;border-radius:6px;
    box-shadow:inset 0 -4px 0 #e5e7eb;
    margin-right:-1px;
    vertical-align:bottom;
  }
  .black{
    position:absolute;
    width:32px; height:110px;
    background:#111;color:#fafafa;
    border:1px solid #000;border-radius:6px;z-index:2;
    box-shadow:inset 0 -6px 0 #000;
  }

  .key kbd{
    position:absolute;bottom:6px;left:0;right:0;
    text-align:center;font-size:12px;color:#555;pointer-events:none;user-select:none
  }
  .playing{outline:3px solid var(--accent);filter:drop-shadow(0 0 10px rgba(34,211,238,.6))}

  .toggle{display:inline-flex;gap:8px;align-items:center;padding:10px 12px;border:1px solid #334155;border-radius:10px;background:#0b1220;cursor:pointer}
  .toggle input{accent-color:var(--accent)}
  label{color:var(--muted);font-size:13px}
  select, input[type="range"], button{width:100%;margin-top:6px;background:#0b1220;border:1px solid #334155;color:#e5e7eb;padding:10px;border-radius:10px}
  button.primary{background:linear-gradient(135deg,var(--accent),var(--accent2));border:none;color:#0b0b0b;font-weight:700}
  .fineprint{color:var(--muted);font-size:12px;margin-top:10px}
  .pill{display:inline-block;border:1px solid #334155;padding:6px 10px;border-radius:999px;font-size:12px;margin-right:8px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .badges{margin-top:8px}
  .status{font-variant-numeric:tabular-nums}
  footer{max-width:1000px;margin:20px auto 40px;padding:0 16px;color:#94a3b8}

  @media (max-width:680px){
    .white{width:40px;height:160px}
    .black{width:26px;height:95px}
  }
</style>
</head>
<body>
<header>
  <h1>üéπ Browser Harmonium ‚Äî free, single-file</h1>
</header>
<main>
  <div class="row">
    <section class="card controls">
      <div class="grid2">
        <div>
          <label>Root (Sa / tonic)</label>
          <select id="root">
            <option value="0">C</option><option value="1">C‚ôØ/D‚ô≠</option><option value="2">D</option>
            <option value="3">D‚ôØ/E‚ô≠</option><option value="4">E</option><option value="5">F</option>
            <option value="6">F‚ôØ/G‚ô≠</option><option value="7">G</option><option value="8">G‚ôØ/A‚ô≠</option>
            <option value="9">A</option><option value="10">A‚ôØ/B‚ô≠</option><option value="11">B</option>
          </select>
        </div>
        <div>
          <label>Transpose (semitones)</label>
          <input id="transpose" type="range" min="-12" max="12" value="0" />
        </div>
      </div>
      <div class="grid2">
        <div>
          <label>Brilliance (filter)</label>
          <input id="brightness" type="range" min="200" max="6000" value="2000" />
        </div>
        <div>
          <label>Chorus depth</label>
          <input id="chorus" type="range" min="0" max="1" step="0.01" value="0.35" />
        </div>
      </div>
      <div class="grid2">
        <div>
          <label>Tremolo (amount)</label>
          <input id="tremAmt" type="range" min="0" max="1" step="0.01" value="0.08" />
        </div>
        <div>
          <label>Volume</label>
          <input id="volume" type="range" min="0" max="1" step="0.01" value="0.8" />
        </div>
      </div>

      <p class="badges">
        <span class="pill">Click the page, then play</span>
        <span class="pill">Space = bellows</span>
        <span class="pill">Shift = sustain</span>
        <span class="pill">1 ‚Üí Sa drone</span>
        <span class="pill">2 ‚Üí Pa drone</span>
      </p>

      <div class="grid2" style="margin-top:8px">
        <button id="recordBtn">‚è∫Ô∏è Record (WEBM)</button>
        <button id="clearRecBtn">üóëÔ∏è Reset</button>
      </div>
      <button id="panicBtn" style="margin-top:8px">üÜò Panic (All Notes Off)</button>
      <p id="recStatus" class="fineprint status">Not recording.</p>
      <p class="fineprint">License: MIT. Fully client-side, no tracking. Host anywhere (static.app, GitHub Pages, Netlify, Vercel).</p>
    </section>

    <section class="card keyboard" id="keys"></section>
  </div>
</main>

<footer>
  <p>Keyboard layout: Z X C V B N M , . / for white keys (starting at C4). Upper row & numbers for sharps.</p>
</footer>

<script>
(() => {
  // Fixed: correct accidental names directly (no post-fix)
  const NOTE_NAMES = ['C','C‚ôØ','D','D‚ôØ','E','F','F‚ôØ','G','G‚ôØ','A','A‚ôØ','B'];

  const BASE_MIDI = 60; // C4

  // Physical-key mapping (layout-safe). label shown on keys.
  const KEYMAP = [
    { code:'KeyZ', label:'Z', n:0 },  { code:'KeyS', label:'S', n:1 },
    { code:'KeyX', label:'X', n:2 },  { code:'KeyD', label:'D', n:3 },
    { code:'KeyC', label:'C', n:4 },  { code:'KeyV', label:'V', n:5 },
    { code:'KeyG', label:'G', n:6 },  { code:'KeyB', label:'B', n:7 },
    { code:'KeyH', label:'H', n:8 },  { code:'KeyN', label:'N', n:9 },
    { code:'KeyJ', label:'J', n:10 }, { code:'KeyM', label:'M', n:11 },
    { code:'Comma', label:',', n:12 },{ code:'KeyL', label:'L', n:13 },
    { code:'Period', label:'.', n:14 },{ code:'Semicolon', label:';', n:15 },
    { code:'Slash', label:'/', n:16 },
    // upper row for sharps / higher notes
    { code:'KeyQ', label:'Q', n:12 }, { code:'Digit2', label:'2', n:13 },
    { code:'KeyW', label:'W', n:14 }, { code:'Digit3', label:'3', n:15 },
    { code:'KeyE', label:'E', n:16 }, { code:'KeyR', label:'R', n:17 },
    { code:'Digit5', label:'5', n:18 },{ code:'KeyT', label:'T', n:19 },
    { code:'Digit6', label:'6', n:20 },{ code:'KeyY', label:'Y', n:21 },
    { code:'Digit7', label:'7', n:22 },{ code:'KeyU', label:'U', n:23 },
    { code:'KeyI', label:'I', n:24 },
  ];
  const keyByCode = code => KEYMAP.find(k => k.code === code) || null;
  const labelForMidi = midi => (KEYMAP.find(k => BASE_MIDI + k.n === midi)?.label || '');

  // ---------- AUDIO ENGINE ----------
  let audio, master, outGain, filter, chorusDelay, chorusLFO, chorusDepthGain, tremLFO, tremDepthGain, bellows, mediaDest, mediaRec;
  let sustain = false;
  let held = new Map(); // tag -> voice
  let sustained = new Set();
  let drones = { sa:false, pa:false };
  let settings = { root:0, transpose:0, brightness:2000, chorus:0.35, tremAmt:0.08, volume:0.8 };
  function mtof(m){ return 440 * Math.pow(2, (m-69)/12); }

  function ensureAudio() {
    if (audio) return;
    audio = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });

    bellows = audio.createGain(); bellows.gain.value = 0.6;
    filter = audio.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value = settings.brightness; filter.Q.value = 0.7;

    chorusDelay = audio.createDelay(0.03); chorusDelay.delayTime.value = 0.014;
    chorusLFO = audio.createOscillator(); chorusLFO.frequency.value = 0.9;
    chorusDepthGain = audio.createGain(); chorusDepthGain.gain.value = settings.chorus * 0.006;
    chorusLFO.connect(chorusDepthGain).connect(chorusDelay.delayTime); chorusLFO.start();

    tremLFO = audio.createOscillator(); tremLFO.frequency.value = 5.2;
    tremDepthGain = audio.createGain(); tremDepthGain.gain.value = settings.tremAmt;
    tremLFO.connect(tremDepthGain); tremLFO.start();

    const tremMult = audio.createGain();
    tremDepthGain.connect(tremMult.gain);
    tremMult.gain.value = 1 - settings.tremAmt;

    outGain = audio.createGain(); outGain.gain.value = settings.volume;
    mediaDest = audio.createMediaStreamDestination();

    const mix = audio.createGain(); mix.gain.value = 1;
    const chorusMix = audio.createGain(); chorusMix.gain.value = 0.8;

    master = audio.createGain(); master.gain.value = 1;
    master.connect(filter);
    filter.connect(mix);
    filter.connect(chorusDelay).connect(chorusMix);
    chorusMix.connect(mix);

    mix.connect(tremMult).connect(bellows).connect(outGain).connect(audio.destination);
    outGain.connect(mediaDest);

    startBellows();

    const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
      ? 'audio/webm;codecs=opus'
      : (MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : '');
    try { mediaRec = new MediaRecorder(mediaDest.stream, mime ? {mimeType:mime} : undefined); } catch { mediaRec = new MediaRecorder(mediaDest.stream); }
    mediaRecChunks = [];
    mediaRec.ondataavailable = e => { if (e.data.size) mediaRecChunks.push(e.data); };
    mediaRec.onstop = () => {
      const blob = new Blob(mediaRecChunks, { type: mime || 'audio/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `harmonium-${Date.now()}.webm`;
      a.textContent = 'Download recording';
      const status = document.getElementById('recStatus');
      status.innerHTML = '';
      status.appendChild(a);
      mediaRecChunks = [];
    };
  }

  function startBellows(){
    let pumping = false;
    let pressure = 0.7;
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.05, (now - last)/1000); last = now;
      const target = pumping ? 1.0 : 0.55;
      pressure += (target - pressure) * (pumping ? 4*dt : 0.8*dt);
      if (bellows) bellows.gain.value = pressure;
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
    window.addEventListener('keydown', e => { if (e.code==='Space'){ pumping=true; e.preventDefault(); }});
    window.addEventListener('keyup',   e => { if (e.code==='Space'){ pumping=false; e.preventDefault(); }});
  }

  function makeVoice(freq){
    const g = audio.createGain(); g.gain.value = 0.0;
    const o1 = audio.createOscillator(); o1.type='sawtooth'; o1.frequency.value = freq * 0.998;
    const o2 = audio.createOscillator(); o2.type='sawtooth'; o2.frequency.value = freq * 1.003;
    const o3 = audio.createOscillator(); o3.type='square';   o3.frequency.value = freq * 2;
    const o3g = audio.createGain(); o3g.gain.value = 0.08;
    const bp1 = audio.createBiquadFilter(); bp1.type='bandpass'; bp1.frequency.value = 780;  bp1.Q.value=0.8;
    const bp2 = audio.createBiquadFilter(); bp2.type='bandpass'; bp2.frequency.value = 1800; bp2.Q.value=1.0;

    o1.connect(g); o2.connect(g); o3.connect(o3g).connect(g);
    g.connect(bp1).connect(bp2).connect(master);

    o1.start(); o2.start(); o3.start();
    g.gain.setTargetAtTime(1.0, audio.currentTime, 0.02);

    return {
      node:g,
      stop(release=0.04){
        const t = audio.currentTime;
        g.gain.setTargetAtTime(0, t, Math.max(0.01, release));
        setTimeout(() => { try{ o1.stop(); o2.stop(); o3.stop(); g.disconnect(); }catch{} }, 400);
      }
    };
  }

  function play(midi, tag){
    ensureAudio();
    const transposed = midi + settings.transpose + settings.root;
    const freq = mtof(transposed);
    const v = makeVoice(freq);
    held.set(tag, v);
    markKey(tag, true);
  }
  function release(tag){
    const v = held.get(tag);
    if (!v) return;
    if (sustain) { sustained.add(tag); return; }
    v.stop();
    held.delete(tag);
    markKey(tag, false);
  }
  function allNotesOff(){
    held.forEach(v => v.stop());
    held.clear();
    sustained.clear();
    document.querySelectorAll('.key').forEach(el=>el.classList.remove('playing'));
  }

  // ---------- BUILD ONE-LINE KEYBOARD ----------
  const keysEl = document.getElementById('keys');
  function buildKeyboard(){
    const startMidi = BASE_MIDI;   // C4
    const count = 25;              // ~2 octaves
    const W = 50;                  // white width
    const B = 32;                  // black width

    keysEl.innerHTML = '';
    keysEl.style.position = 'relative';
    keysEl.style.display = 'inline-block';
    keysEl.style.whiteSpace = 'nowrap';
    keysEl.style.overflowX = 'auto';

    const whitePos = new Map();
    // 1) lay out whites
    let x = 0;
    for (let i=0;i<count;i++){
      const midi = startMidi + i;
      const n = midi % 12;
      if ([1,3,6,8,10].includes(n)) continue; // skip blacks here

      const noteName = NOTE_NAMES[n] + Math.floor(midi/12 - 1);
      const w = document.createElement('div');
      w.className = 'key white'; w.dataset.midi = midi;
      const letter = labelForMidi(midi);
      w.innerHTML = `<kbd>${noteName}<br><strong style="font-size:13px;color:#111">${letter}</strong></kbd>`;

      const start = ev => { ev.preventDefault(); play(midi, 'mouse:'+midi); };
      const end   = () => release('mouse:'+midi);
      w.addEventListener('mousedown', start);
      w.addEventListener('mouseup', end);
      w.addEventListener('mouseleave', end);
      w.addEventListener('touchstart', start, {passive:false});
      w.addEventListener('touchend', end);

      w.style.left = x+'px';
      keysEl.appendChild(w);
      whitePos.set(midi, x);
      x += W;
    }

    const leftWhiteForBlack = {1:0, 3:2, 6:5, 8:7, 10:9}; // C#,D#,F#,G#,A# anchors

    // 2) lay out blacks between whites
    for (let i=0;i<count;i++){
      const midi = startMidi + i;
      const n = midi % 12;
      if (![1,3,6,8,10].includes(n)) continue;

      const octaveStart = startMidi + Math.floor((midi - startMidi)/12)*12;
      const leftWhiteMidi = octaveStart + leftWhiteForBlack[n];
      if (!whitePos.has(leftWhiteMidi)) continue; // edge of range

      const leftX = whitePos.get(leftWhiteMidi);
      const bx = leftX + Math.round(W*0.66) - Math.round(B/2);

      const noteName = NOTE_NAMES[n] + Math.floor(midi/12 - 1);
      const b = document.createElement('div');
      b.className = 'key black'; b.dataset.midi = midi;
      const letter = labelForMidi(midi);
      b.innerHTML = `<kbd style="color:#fff">${noteName}<br><strong style="font-size:13px;color:#fff">${letter}</strong></kbd>`;
      b.style.left = bx+'px'; b.style.top = '0px';

      const start = ev => { ev.preventDefault(); play(midi, 'mouse:'+midi); };
      const end   = () => release('mouse:'+midi);
      b.addEventListener('mousedown', start);
      b.addEventListener('mouseup', end);
      b.addEventListener('mouseleave', end);
      b.addEventListener('touchstart', start, {passive:false});
      b.addEventListener('touchend', end);

      keysEl.appendChild(b);
    }
  }

  function markKey(tag, on){
    const el = findKeyEl(tag);
    if (el){ el.classList.toggle('playing', !!on); }
  }
  function findKeyEl(tag){
    if (tag.startsWith('mouse:')) {
      const midi = +tag.split(':')[1];
      return [...document.querySelectorAll('.key')].find(k => +k.dataset.midi===midi);
    } else if (tag.startsWith('key:')) {
      const code = tag.slice(4);
      const map = keyByCode(code);
      if (!map) return null;
      const midi = BASE_MIDI + map.n;
      return [...document.querySelectorAll('.key')].find(k => +k.dataset.midi===midi);
    }
    return null;
  }

  // ---------- KEYBOARD HANDLERS ----------
  const down = new Set();

  window.addEventListener('keydown', e => {
    if (e.code === 'Escape') { allNotesOff(); return; } // panic via ESC
    if (e.repeat) return;

    if (e.key === 'Shift') { sustain = true; e.preventDefault(); return; }
    if (e.code === 'Digit1') { toggleDrone('sa'); return; }
    if (e.code === 'Digit2') { toggleDrone('pa'); return; }

    const m = keyByCode(e.code);
    if (m) {
      if (down.has(e.code)) return;
      down.add(e.code);
      play(BASE_MIDI + m.n, 'key:'+e.code);
      e.preventDefault();
    }
  });

  window.addEventListener('keyup', e => {
    if (e.key === 'Shift') {
      sustain = false;
      sustained.forEach(tag => { const v = held.get(tag); if (v){ v.stop(); held.delete(tag); markKey(tag,false); } });
      sustained.clear();
      return;
    }
    const m = keyByCode(e.code);
    if (m) {
      down.delete(e.code);
      release('key:'+e.code);
    }
  });

  window.addEventListener('blur', allNotesOff);
  document.getElementById('panicBtn').addEventListener('click', allNotesOff);

  // ---------- Drones ----------
  function playDrone(which, on){
    ensureAudio();
    const rootMidi = BASE_MIDI + settings.root;
    const midi = which==='sa' ? rootMidi : rootMidi + 7;
    const freq = mtof(midi);
    if (on){
      const v = makeVoice(freq);
      v.node.gain.setTargetAtTime(0.7, audio.currentTime, 0.05);
      held.set('drone:'+which, v);
    } else {
      const v = held.get('drone:'+which);
      if (v){ v.stop(0.2); held.delete('drone:'+which); }
    }
  }
  function toggleDrone(which){
    drones[which] = !drones[which];
    playDrone(which, drones[which]);
  }

  // ---------- Controls ----------
  function link(id, handler){
    const el = document.getElementById(id);
    handler(el);
    el.addEventListener('input', () => handler(el));
  }
  link('root', el => { settings.root = +el.value; });
  link('transpose', el => { settings.transpose = +el.value; });
  link('brightness', el => { settings.brightness = +el.value; if (filter) filter.frequency.value = settings.brightness; });
  link('chorus', el => { settings.chorus = +el.value; if (chorusDepthGain) chorusDepthGain.gain.value = settings.chorus * 0.006; });
  link('tremAmt', el => {
    settings.tremAmt = +el.value;
    if (tremDepthGain) tremDepthGain.gain.value = settings.tremAmt;
    if (outGain) outGain.gain.value = settings.volume * (0.95 + 0.05*(1-settings.tremAmt));
  });
  link('volume', el => { settings.volume = +el.value; if (outGain) outGain.gain.value = settings.volume; });

  // Recording buttons
  let mediaRecChunks = []; // <‚Äî Fixed: only declare chunks here
  document.getElementById('recordBtn').addEventListener('click', () => {
    ensureAudio();
    if (!mediaRec) return;
    if (mediaRec.state === 'recording') {
      mediaRec.stop();
      document.getElementById('recordBtn').textContent = '‚è∫Ô∏è Record (WEBM)';
      document.getElementById('recStatus').textContent = 'Processing‚Ä¶';
    } else {
      mediaRecChunks = [];
      try { mediaRec.start(); } catch {}
      document.getElementById('recordBtn').textContent = '‚èπÔ∏è Stop';
      document.getElementById('recStatus').textContent = 'Recording‚Ä¶ play with keys!';
    }
  });
  document.getElementById('clearRecBtn').addEventListener('click', () => {
    document.getElementById('recStatus').textContent = 'Not recording.';
  });

  // Build UI and arm audio on first gesture
  buildKeyboard();
  window.addEventListener('pointerdown', ensureAudio, { once:true });
  document.body.addEventListener('click', ensureAudio, { once: true });
})();
</script>
</body>
</html>
